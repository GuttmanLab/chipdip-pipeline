"""
Rename and reorder chromosomes in a BAM file, and select only reads aligned to those chromosomes
"""
import argparse
import os
import re
import shutil
import pysam



def main():
    args = parse_arguments()
    if args.chrom_map is None:
        if args.force_copy is False:
            os.symlink(os.path.abspath(args.input), args.output)
        else:
            shutil.copy(args.input, args.output)
    else:
        chrom_map = parse_chrom_map(args.chrom_map)
        filter_reads(args.input, args.output, chrom_map, threads=args.threads, verbose=not args.quiet)


def positive_int(value):
    """
    Check that a string represents a positive integer.
    Source: https://stackoverflow.com/a/14117511
    """
    ivalue = int(value)
    if ivalue <= 0:
        raise argparse.ArgumentTypeError("%s is an invalid positive int value" % value)
    return ivalue


def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Rename chromosomes and keep only reads aligned to selected chromosomes."
    )
    parser.add_argument("input", metavar="in.bam", help="Input BAM file")
    parser.add_argument("output", metavar="out.bam", help="Output BAM file")
    parser.add_argument("-c", "--chrom_map", metavar="PATH", help="Chromosome name map file")
    parser.add_argument(
        "--force-copy",
        action="store_true",
        help=(
            "If -c/--chrom_map is not specified (i.e., no changes are required), still make "
            "a copy of the input BAM file (otherwise defaults to making a symbolic link)"
        ),
    )
    parser.add_argument(
        "-t",
        "--threads",
        type=positive_int,
        default=1,
        metavar="#",
        help="Number of threads to use for compressing/decompressing BAM files",
    )
    parser.add_argument(
        "-q",
        "--quiet",
        action="store_true",
        help="Do not print the number of discarded reads and output reads.",
    )
    return parser.parse_args()


def parse_chrom_map(path):
    """
    Parse a chromosome name map file to a dict mapping old chromosome names to new names.
    """
    REGEX_RNAME = re.compile(r'[0-9A-Za-z!#$%&+./:;?@^_|~-][0-9A-Za-z!#$%&*+./:;=?@^_|~-]*')
    chrom_map = dict()
    with open(path, 'rt') as f:
        for line in f:
            if line.strip() == '' or line.strip().startswith('"'):
                continue
            old_name, new_name = line.strip().split("\t")
            assert REGEX_RNAME.match(old_name) and REGEX_RNAME.match(new_name), \
                ("At least one of these chromosome names in the chromosome name map is invalid: ",
                 f"{old_name} or {new_name}")
            assert old_name not in chrom_map, \
                f"The chromosome name '{old_name}' is repeated in the chromosome name map."
            chrom_map[old_name] = new_name
    return chrom_map


def reheader(old_header, chrom_map):
    """
    Rename and reorder reference sequence names.

    Args
    - old_header: dict (str -> str)
        Representation of SAM/BAM file header of existing BAM file as a Python
        dictionary, as used by pysam. For example, generated by
        `pysam.AlignmentFile.header.to_dict()`
    - chrom_map: dict (str -> str)
        Map from old reference sequence names to new reference sequence names.
        The order of entries in this dictionary defines the new alignment sorting order.

    Returns
    - new_header: dict
        Representation of SAM/BAM file header as a Python dictionary, as used by pysam
    - old_to_new_refID: dict (int -> int)
        Map from old reference ID to new reference ID

    Note: The current implementation of this function takes advantage of dict features
    defined/introduced in Python versions >= 3.9.
    """
    # copy existing BAM header to a new header dict without reference sequences
    new_header = old_header.copy()
    new_header["SQ"] = [None] * len(chrom_map)

    # populate new header dict with renamed reference sequences
    chrom_to_index = {chrom: i for i, chrom in enumerate(chrom_map.keys())}
    old_to_new_refID = dict()
    for i, ref_seq_dict in enumerate(old_header["SQ"]):
        old_SN = ref_seq_dict["SN"]
        if old_SN in chrom_map:
            new_header["SQ"][chrom_to_index[old_SN]] = ref_seq_dict | {"SN": chrom_map[old_SN]}
            old_to_new_refID[i] = chrom_to_index[old_SN]

    # check that all chromosomes in chrom_map are in the new header dict
    assert list(chrom_map.values()) == [ref_seq_dict["SN"] for ref_seq_dict in new_header["SQ"]], \
        "Not all chromosomes in the specified chromsome name map were in the original BAM header."

    return new_header, old_to_new_refID


def filter_reads(path_bam_in, path_bam_out, chrom_map, threads=1, verbose=True):
    """
    Discard reads that do not map to the specified chromosomes, and
    generate a new header for only the specified chromosomes.

    Args
    - path_bam_in: str
        Path to input BAM file
    - path_bam_out: str
        Path to output BAM file
    - chrom_map: dict (str -> str)
        Map from old reference sequence names to new reference sequence names.
        The order of entries in this dictionary defines the new alignment sorting order.
    - threads: int. default=1
        Number of threads to use for compressing/decompressing BAM files
    - verbose: bool. default=True
        Print the number of discarded reads and the number of output reads.
    """
    count_discard = 0
    count_out = 0
    with pysam.AlignmentFile(path_bam_in, "rb", threads=threads) as file_bam_in:
        old_header = file_bam_in.header.to_dict()
        new_header, old_to_new_refID = reheader(old_header, chrom_map)
        with pysam.AlignmentFile(path_bam_out, "wb", header=new_header) as file_bam_out:
            for read in file_bam_in.fetch(until_eof=True):
                if read.reference_name in chrom_map:
                    # update reference ID of read to match the order of reference sequences in the new header
                    read.reference_id = old_to_new_refID[read.reference_id]
                    file_bam_out.write(read)
                    count_out += 1
                else:
                    count_discard += 1
    if verbose:
        print("Discarded reads:", count_discard)
        print("Written out reads:", count_out)


if __name__ == "__main__":
    main()
