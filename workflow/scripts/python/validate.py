import argparse
import json
import os
import re
import sys
sys.path.append(os.path.abspath(os.path.dirname(__file__)))
from helpers import parse_chrom_map, GZIP_MAGIC_NUMBER, file_open
import yaml


# Required keys for all modes
REQUIRED_KEYS_COMMON = (
    'samples',
    'bowtie2_index',
)

# Required keys for BarcodeIdentification.jar mode
REQUIRED_KEYS_BID = (
    'barcode_config',
    'cutadapt_dpm',
    'cutadapt_oligos',
    'bead_umi_length'
)

# Required keys for splitcode mode
REQUIRED_KEYS_SPLITCODE = (
    'splitcode-configs',
    'num_tags_oligo',
    'num_tags_chromatin',
)

# Legacy required keys (for backwards compatibility)
REQUIRED_KEYS = (
    'scripts_dir',
    'samples',
    'barcode_config',
    'bowtie2_index',
    'cutadapt_dpm',
    'cutadapt_oligos',
    'bead_umi_length'
)

REQUIRED_KEYS_PE = (
    'samples',
    'splitcode-configs',
    'bowtie2_index',
    'num_tags_oligo',
    'num_tags_chromatin',
)


def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Check for common mistakes in configuring ChIP-DIP pipeline"
    )
    parser.add_argument(
        "-c",
        "--config",
        metavar="FILE",
        help=("path to JSON or YAML file of pipeline config. Parameters provided via additional arguments (e.g., "
              "--chrom_map) will supersede values in the config file."),
    )
    parser.add_argument(
        "--chrom_map",
        metavar="FILE",
        help="path to chromosome name map file (e.g., chrom_map.json)",
    )
    parser.add_argument(
        "--bt2_index_summary",
        metavar="FILE",
        help="path to Bowtie 2 index summary (i.e., bowtie2-inspect --summary <index>)",
    )
    parser.add_argument(
        "--mask",
        metavar="FILE",
        help="path to mask BED file",
    )
    parser.add_argument(
        "--pipeline",
        metavar="pipeline.yaml",
        help=(
            "path to pipeline DAG description file (YAML format). Mapping from level to a mapping describing that "
            "output. Except for a 'data' level, the secondary mapping must contain the key 'path' mapping to a list of "
            "strings that form the path pattern for that output."
        )
    )
    parser.add_argument(
        "--paired",
        action="store_true"
    )
    parser.add_argument(
        "-q", "--quiet", action="store_true", help="suppress output"
    )
    return parser.parse_args()


def validate_samples(path_samples, paired_end=True):
    '''
    Validate samples.json file

    Args:
    - path_samples: path to samples.json file
    - paired_end: if True, validate that R2 files are present
    '''
    with open(path_samples) as f:
        files = json.load(f)
    for sample, d in files.items():
        assert '.' not in sample, \
            f"Error in {path_samples}. Sample names are not allowed to contain periods."
        assert 'R1' in d, \
            f"Error in {path_samples}. Each sample must have read 1 (R1) files."
        if paired_end:
            assert 'R2' in d and len(d.get('R2', [])) > 0, \
                f"Error in {path_samples}. Sample '{sample}' is missing R2 files but paired_end=true."
        all_files = d.get("R1", []) + d.get("R2", [])
        for path in all_files:
            with open(path, "rb") as f:
                assert f.read(2) == GZIP_MAGIC_NUMBER, \
                    f"Error in {path_samples}. FASTQ file {path} does not appear to be gzip compressed."


def validate_config(config):
    # check that temp_dir is writeable
    pass


def validate_format():
    pass


def validate_chrom_map(path_chrom_map, path_bt2_index_summary, chrom_map=None, chrom_sizes=None, verbose=True):
    """
    Validate the chromosome name map against the Bowtie 2 index - i.e.,
    all chromosome names to be renamed should be in the Bowtie 2 index.

    Args
    - path_chrom_map: str
        Path to chromsome name map file.
    - path_bt2_index_summary: str
        Path to Bowtie2 index summary, as generated by `bowtie2-inspect --summary <bt2_base>`
    - chrom_map: dict[str, str]. default=None
        Mapping from old chromosome name to new chromosome name.
        If not provided, generate by parsing the chromosome name map file.
    - chrom_sizes: dict[str, int]. default=None
        Mapping from chromosome name to length.
        If not provided, generate by parsing the Bowtie 2 index summary.
    - verbose: bool. default=True
        If True, print the genome size of the Bowtie 2 index and the chromosome map.

    Returns None if chromosome name map is valid.
    Raises AssertionError if chromosome name map is invalid.
    """
    if chrom_sizes is None:
        chrom_sizes = parse_bt2_index_summary(path_bt2_index_summary)
    if chrom_map is None:
        chrom_map = parse_chrom_map(path_chrom_map)
    genome_size = 0
    for chrom in chrom_map:
        assert chrom in chrom_sizes, (
            "Chromosome '{}' specified in chromosome name map '{}' not found in "
            "Bowtie 2 index summary '{}'"
        ).format(chrom, path_chrom_map, path_bt2_index_summary)
        genome_size += chrom_sizes[chrom]
    if verbose:
        print("Genome size of Bowtie 2 index:", sum(chrom_sizes.values()))
        print("Genome size of chromosome map:", genome_size)


def validate_mask(path_mask: str, chrom_map=None, chrom_sizes=None) -> None:
    """
    Check that chromosome names in the mask file match those in the chromosome name map (if provided) or
    in the Bowtie2 index (if the chromosome name map is not provided).

    At least one of chrom_map or chrom_sizes must be provided.
    If chrom_map is provided, chrom_sizes is ignored.

    Args
    - path_mask: path to BED file (may be gzip-compressed)
    - chrom_map: chromosome name map
    - chrom_sizes: chromosome sizes (obtained from Bowtie2 index summary)
      - Ignored if chrom_map is provided

    Returns: None

    Raises: AssertionError if any chromosome names in the mask file do not match those in the chromosome name map
    or in the Bowtie2 index.
    """
    if chrom_map is None and chrom_sizes is None:
        raise ValueError(
            "Either a chromosome name map or a Bowtie2 index summary must be provided to validate the mask file."
        )
    if chrom_map is not None:
        chrom_name_source = 'chromosome name map'
        valid_chroms = set(chrom_map.values())
    else:
        chrom_name_source = 'Bowtie2 index'
        valid_chroms = set(chrom_sizes.keys())

    mask_chroms_not_in_valid_chroms = set()
    at_least_one_valid_chrom = False
    with file_open(path_mask, mode='rt') as f:
        for line in f:
            line = line.strip()
            if line == '' or line.startswith('#'):
                continue
            chrom, *_ = line.split()
            if chrom not in valid_chroms:
                mask_chroms_not_in_valid_chroms.add(chrom)
            else:
                at_least_one_valid_chrom = True
    for chrom in mask_chroms_not_in_valid_chroms:
        print(f"Chromosome '{chrom}' in mask file '{path_mask}' not found in {chrom_name_source}.", file=sys.stderr)
    assert at_least_one_valid_chrom, \
        f'Mask BED file {path_mask} does not contain any regions from chromosomes in the {chrom_name_source}.'


def validate_pipeline_structure(pipeline: dict):
    """
    Validate that the pipeline structure adheres to the following:
    1. Read output paths end with expected extensions: .fastq.gz, .fq.gz, or .bam
    2. Parent and base levels (if specified) exist in the pipeline structure.

    Args
    - pipeline: mapping from level to a structured information (a dictionary) describing that output. Except for the
        "data" level, the info dict must contain the key "path" mapping to a list of strings that form the path pattern
        for that output.

    Returns: None

    Raises
    - ValueError: if any path pattern does not end with a recognized file extension
    - AssertionError if any level (except "data") is missing a "path" key or if any specified parent/base level does
      not exist.
    """
    for level, info in pipeline.items():
        if level != "data":
            assert "path" in info, f"Pipeline level {level} must contain a 'path' key."
        path = info.get('path')
        if path and not path[-1].endswith(('.fastq', '.fq', '.fastq.gz', '.fq.gz', '.bam')):
            raise ValueError(f"Invalid file extension in path pattern for level {level}: {path}")
        assert info.get("parent") in (None, *pipeline.keys()), \
            f"Parent {info.get('parent')} of level {level} is not a valid level."
        assert info.get("base") in (None, *pipeline.keys()), \
            f"Parent {info.get('base')} of level {level} is not a valid level."


def parse_bt2_index_summary(path_bt2_index_summary):
    """
    Parse the output of `bowtie2-inspect --summary <bt2_base>` to a dictionary mapping
    chromosome name to length. The chromosome name is truncated at the first whitespace,
    per SAM format specifications.
    """
    REGEX_BT2_SEQ_LINE = re.compile(r"^Sequence-\d+")
    chrom_sizes = dict()
    with open(path_bt2_index_summary) as f:
        for line in f:
            if not REGEX_BT2_SEQ_LINE.search(line):
                continue
            parts = line.strip().split("\t")
            name = parts[1]
            refname = name.split()[0]
            length = int(parts[-1])
            chrom_sizes[refname] = length
    return chrom_sizes


def main():
    args = parse_arguments()
    verbose = not args.quiet

    config = dict()
    if args.config:
        with open(args.config) as f:
            if args.config.lower().endswith(".json"):
                config = json.load(f)
            elif args.config.lower().endswith(".yaml") or args.config.lower().endswith(".yml"):
                config = yaml.safe_load(f)
            else:
                raise ValueError("Unrecognized file extension (not .json, .yaml, or .yml) for config file: "
                                 "{}".format(args.config))

    # Determine mode based on config parameters or legacy --paired flag
    paired_end = config.get('paired_end', args.paired)
    barcode_tool = config.get('barcode_tool', 'barcodeidentification').lower()

    # Validate barcode_tool parameter
    assert barcode_tool in ('barcodeidentification', 'splitcode'), \
        f"barcode_tool must be 'barcodeidentification' or 'splitcode', got '{barcode_tool}'"

    # Determine required keys based on barcode_tool
    if barcode_tool == 'barcodeidentification':
        required_keys = REQUIRED_KEYS_COMMON + REQUIRED_KEYS_BID
    else:
        required_keys = REQUIRED_KEYS_COMMON + REQUIRED_KEYS_SPLITCODE

    # Validate required keys
    missing_keys = [key for key in required_keys if key not in config]
    assert len(missing_keys) == 0, \
        f'Config file must contain the following required keys: {", ".join(missing_keys)}'
    print(f'Config file {args.config} contains all required keys.')

    path_chrom_map = args.chrom_map if args.chrom_map else config.get("path_chrom_map", None)
    chrom_map = None
    chrom_sizes = None
    if path_chrom_map:
        chrom_map = parse_chrom_map(path_chrom_map)
    if args.bt2_index_summary:
        chrom_sizes = parse_bt2_index_summary(args.bt2_index_summary)
    if chrom_map is not None and chrom_sizes is not None:
        validate_chrom_map(path_chrom_map, args.bt2_index_summary, chrom_map=chrom_map, chrom_sizes=chrom_sizes, verbose=verbose)
        print('Validated chromosome name map file.')

    validate_samples(config['samples'], paired_end=paired_end)
    print(f'Validated samples file (paired_end={paired_end}, barcode_tool={barcode_tool}).')

    if args.mask and (chrom_map is not None or chrom_sizes is not None):
        validate_mask(config["mask"], chrom_map, chrom_sizes)
        print('Validated mask file.')

    if args.pipeline:
        with open(args.pipeline) as f:
            pipeline = yaml.safe_load(f)
        validate_pipeline_structure(pipeline)
        print('Validated pipeline structure.')
    # validate_config(config)
    # validate_format(config["format"])


if __name__ == "__main__":
    main()
